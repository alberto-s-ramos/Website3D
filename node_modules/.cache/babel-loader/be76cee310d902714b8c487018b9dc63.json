{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/alberto/Projects/Personal/Website3D/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/Users/alberto/Projects/Personal/Website3D/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/alberto/Projects/Personal/Website3D/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { colorToRgb, getDistance, getLinkColor, getRangeValue } from \"tsparticles-engine\";\nimport { drawLinkLine as _drawLinkLine, drawLinkTriangle as _drawLinkTriangle } from \"./Utils\";\nexport var LinkInstance = /*#__PURE__*/function () {\n  function LinkInstance(container) {\n    _classCallCheck(this, LinkInstance);\n\n    this.container = container;\n  }\n\n  _createClass(LinkInstance, [{\n    key: \"particleCreated\",\n    value: function particleCreated(particle) {\n      var linkParticle = particle;\n      linkParticle.links = [];\n    }\n  }, {\n    key: \"particleDestroyed\",\n    value: function particleDestroyed(particle) {\n      var linkParticle = particle;\n      linkParticle.links = [];\n    }\n  }, {\n    key: \"drawParticle\",\n    value: function drawParticle(context, particle) {\n      var _this = this;\n\n      var linkParticle = particle,\n          container = this.container,\n          particles = container.particles,\n          pOptions = particle.options;\n\n      if (linkParticle.links.length <= 0) {\n        return;\n      }\n\n      context.save();\n      var p1Links = linkParticle.links.filter(function (l) {\n        var linkFreq = container.particles.getLinkFrequency(linkParticle, l.destination);\n        return linkFreq <= pOptions.links.frequency;\n      });\n\n      var _iterator = _createForOfIteratorHelper(p1Links),\n          _step;\n\n      try {\n        var _loop = function _loop() {\n          var link = _step.value;\n          var p2 = link.destination;\n\n          if (pOptions.links.triangles.enable) {\n            var links = p1Links.map(function (l) {\n              return l.destination;\n            }),\n                vertices = p2.links.filter(function (t) {\n              var linkFreq = container.particles.getLinkFrequency(p2, t.destination);\n              return linkFreq <= p2.options.links.frequency && links.indexOf(t.destination) >= 0;\n            });\n\n            if (vertices.length) {\n              var _iterator2 = _createForOfIteratorHelper(vertices),\n                  _step2;\n\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var vertex = _step2.value;\n                  var p3 = vertex.destination,\n                      triangleFreq = particles.getTriangleFrequency(linkParticle, p2, p3);\n\n                  if (triangleFreq > pOptions.links.triangles.frequency) {\n                    continue;\n                  }\n\n                  _this.drawLinkTriangle(linkParticle, link, vertex);\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n            }\n          }\n\n          if (link.opacity > 0 && container.retina.linksWidth > 0) {\n            _this.drawLinkLine(linkParticle, link);\n          }\n        };\n\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      context.restore();\n    }\n  }, {\n    key: \"drawLinkTriangle\",\n    value: function drawLinkTriangle(p1, link1, link2) {\n      var _a;\n\n      var container = this.container,\n          options = container.actualOptions,\n          p2 = link1.destination,\n          p3 = link2.destination,\n          triangleOptions = p1.options.links.triangles,\n          opacityTriangle = (_a = triangleOptions.opacity) !== null && _a !== void 0 ? _a : (link1.opacity + link2.opacity) / 2;\n\n      if (opacityTriangle <= 0) {\n        return;\n      }\n\n      container.canvas.draw(function (ctx) {\n        var pos1 = p1.getPosition();\n        var pos2 = p2.getPosition();\n        var pos3 = p3.getPosition();\n\n        if (getDistance(pos1, pos2) > container.retina.linksDistance || getDistance(pos3, pos2) > container.retina.linksDistance || getDistance(pos3, pos1) > container.retina.linksDistance) {\n          return;\n        }\n\n        var colorTriangle = colorToRgb(triangleOptions.color);\n\n        if (!colorTriangle) {\n          var linksOptions = p1.options.links,\n              linkColor = linksOptions.id !== undefined ? container.particles.linksColors.get(linksOptions.id) : container.particles.linksColor;\n          colorTriangle = getLinkColor(p1, p2, linkColor);\n        }\n\n        if (!colorTriangle) {\n          return;\n        }\n\n        _drawLinkTriangle(ctx, pos1, pos2, pos3, options.backgroundMask.enable, options.backgroundMask.composite, colorTriangle, opacityTriangle);\n      });\n    }\n  }, {\n    key: \"drawLinkLine\",\n    value: function drawLinkLine(p1, link) {\n      var container = this.container,\n          options = container.actualOptions,\n          p2 = link.destination,\n          pos1 = p1.getPosition(),\n          pos2 = p2.getPosition();\n      var opacity = link.opacity;\n      container.canvas.draw(function (ctx) {\n        var _a, _b;\n\n        var colorLine;\n        var twinkle = p1.options.twinkle.lines;\n\n        if (twinkle.enable) {\n          var twinkleFreq = twinkle.frequency,\n              twinkleRgb = colorToRgb(twinkle.color),\n              twinkling = Math.random() < twinkleFreq;\n\n          if (twinkling && twinkleRgb) {\n            colorLine = twinkleRgb;\n            opacity = getRangeValue(twinkle.opacity);\n          }\n        }\n\n        if (!colorLine) {\n          var linksOptions = p1.options.links,\n              linkColor = linksOptions.id !== undefined ? container.particles.linksColors.get(linksOptions.id) : container.particles.linksColor;\n          colorLine = getLinkColor(p1, p2, linkColor);\n        }\n\n        if (!colorLine) {\n          return;\n        }\n\n        var width = (_a = p1.retina.linksWidth) !== null && _a !== void 0 ? _a : container.retina.linksWidth,\n            maxDistance = (_b = p1.retina.linksDistance) !== null && _b !== void 0 ? _b : container.retina.linksDistance;\n\n        _drawLinkLine(ctx, width, pos1, pos2, maxDistance, container.canvas.size, p1.options.links.warp, options.backgroundMask.enable, options.backgroundMask.composite, colorLine, opacity, p1.options.links.shadow);\n      });\n    }\n  }]);\n\n  return LinkInstance;\n}();","map":null,"metadata":{},"sourceType":"module"}