{"ast":null,"code":"import React from 'react';\n\nclass TagCloud {\n  /* constructor */\n  constructor(container = document.body, texts, options) {\n    const self = this;\n    if (!container || container.nodeType !== 1) return new Error('Incorrect element type'); // params\n\n    self.$container = container;\n    self.texts = texts || [];\n    self.config = { ...TagCloud._defaultConfig,\n      ...(options || {})\n    }; // calculate config\n\n    self.radius = self.config.radius; // rolling radius\n\n    self.depth = 2 * self.radius; // rolling depth\n\n    self.size = 1.5 * self.radius; // rolling area size with mouse\n\n    self.maxSpeed = TagCloud._getMaxSpeed(self.config.maxSpeed); // rolling max speed\n\n    self.initSpeed = TagCloud._getInitSpeed(self.config.initSpeed); // rolling init speed\n\n    self.direction = self.config.direction; // rolling init direction\n\n    self.keep = self.config.keep; // whether to keep rolling after mouse out area\n\n    self.paused = false; // keep state to pause the animation\n    // create element\n\n    self._createElment(); // init\n\n\n    self._init(); // set elements and instances\n\n\n    TagCloud.list.push({\n      el: self.$el,\n      container,\n      instance: self\n    });\n  }\n  /* static method */\n  // all TagCloud list\n\n\n  // event listener\n  static _on(el, ev, handler, cap) {\n    if (el.addEventListener) {\n      el.addEventListener(ev, handler, cap);\n    } else if (el.attachEvent) {\n      el.attachEvent(`on${ev}`, handler);\n    } else {\n      el[`on${ev}`] = handler;\n    }\n  }\n  /* instance property method */\n  // create elment\n\n\n  _createElment() {\n    const self = this; // create container\n\n    const $el = document.createElement('div');\n    $el.className = self.config.containerClass;\n\n    if (self.config.useContainerInlineStyles) {\n      $el.style.position = 'relative';\n      $el.style.width = `${2 * self.radius}px`;\n      $el.style.height = `${2 * self.radius}px`;\n    } // create texts\n\n\n    self.items = [];\n    self.texts.forEach((text, index) => {\n      const item = self._createTextItem(text, index);\n\n      $el.appendChild(item.el);\n      self.items.push(item);\n    });\n    self.$container.appendChild($el);\n    self.$el = $el;\n  } // create a text\n\n\n  _createTextItem(text, index = 0) {\n    const self = this;\n    const itemEl = document.createElement('span');\n    itemEl.className = self.config.itemClass;\n\n    if (self.config.useItemInlineStyles) {\n      itemEl.style.willChange = 'transform, opacity, filter';\n      itemEl.style.position = 'absolute';\n      itemEl.style.top = '50%';\n      itemEl.style.left = '50%';\n      itemEl.style.zIndex = index + 1;\n      itemEl.style.filter = 'alpha(opacity=0)';\n      itemEl.style.opacity = 0;\n      const transformOrigin = '50% 50%';\n      itemEl.style.WebkitTransformOrigin = transformOrigin;\n      itemEl.style.MozTransformOrigin = transformOrigin;\n      itemEl.style.OTransformOrigin = transformOrigin;\n      itemEl.style.transformOrigin = transformOrigin;\n      const transform = 'translate3d(-50%, -50%, 0) scale(1)';\n      itemEl.style.WebkitTransform = transform;\n      itemEl.style.MozTransform = transform;\n      itemEl.style.OTransform = transform;\n      itemEl.style.transform = transform;\n    }\n\n    itemEl.innerText = text;\n    return {\n      el: itemEl,\n      ...self._computePosition(index) // distributed in appropriate place\n\n    };\n  } // calculate appropriate place\n\n\n  _computePosition(index, random = false) {\n    const self = this;\n    const textsLength = self.texts.length; // if random `true`, It means that a random appropriate place is generated, and the position will be independent of `index`\n\n    if (random) index = Math.floor(Math.random() * (textsLength + 1));\n    const phi = Math.acos(-1 + (2 * index + 1) / textsLength);\n    const theta = Math.sqrt((textsLength + 1) * Math.PI) * phi;\n    return {\n      x: self.size * Math.cos(theta) * Math.sin(phi) / 2,\n      y: self.size * Math.sin(theta) * Math.sin(phi) / 2,\n      z: self.size * Math.cos(phi) / 2\n    };\n  }\n\n  _requestInterval(fn, delay) {\n    const requestAnimFrame = ((() => window.requestAnimationFrame) || ((callback, element) => {\n      window.setTimeout(callback, 1000 / 60);\n    }))();\n\n    let start = new Date().getTime();\n    const handle = {};\n\n    function loop() {\n      handle.value = requestAnimFrame(loop);\n      const current = new Date().getTime(),\n            delta = current - start;\n\n      if (delta >= delay) {\n        fn.call();\n        start = new Date().getTime();\n      }\n    }\n\n    handle.value = requestAnimFrame(loop);\n    return handle;\n  } // init\n\n\n  _init() {\n    const self = this;\n    self.active = false; // whether the mouse is activated\n\n    self.mouseX0 = self.initSpeed * Math.sin(self.direction * (Math.PI / 180)); // init distance between the mouse and rolling center x axis\n\n    self.mouseY0 = -self.initSpeed * Math.cos(self.direction * (Math.PI / 180)); // init distance between the mouse and rolling center y axis\n\n    self.mouseX = self.mouseX0; // current distance between the mouse and rolling center x axis\n\n    self.mouseY = self.mouseY0; // current distance between the mouse and rolling center y axis\n    // mouseover\n\n    TagCloud._on(self.$el, 'mouseover', () => {\n      self.active = true;\n    }); // mouseout\n\n\n    TagCloud._on(self.$el, 'mouseout', () => {\n      self.active = false;\n    }); // mousemove\n\n\n    TagCloud._on(self.keep ? window : self.$el, 'mousemove', ev => {\n      ev = ev || window.event;\n      const rect = self.$el.getBoundingClientRect();\n      self.mouseX = (ev.clientX - (rect.left + rect.width / 2)) / 5;\n      self.mouseY = (ev.clientY - (rect.top + rect.height / 2)) / 5;\n    }); // update state regularly\n\n\n    self._next(); // init update state\n\n\n    self.interval = self._requestInterval(() => {\n      self._next.call(self);\n    }, 10);\n  } // calculate the next state\n\n\n  _next() {\n    const self = this;\n\n    if (self.paused) {\n      return;\n    } // if keep `false`, pause rolling after moving mouse out area\n\n\n    if (!self.keep && !self.active) {\n      self.mouseX = Math.abs(self.mouseX - self.mouseX0) < 1 ? self.mouseX0 : (self.mouseX + self.mouseX0) / 2; // reset distance between the mouse and rolling center x axis\n\n      self.mouseY = Math.abs(self.mouseY - self.mouseY0) < 1 ? self.mouseY0 : (self.mouseY + self.mouseY0) / 2; // reset distance between the mouse and rolling center y axis\n    }\n\n    const a = -(Math.min(Math.max(-self.mouseY, -self.size), self.size) / self.radius) * self.maxSpeed;\n    const b = Math.min(Math.max(-self.mouseX, -self.size), self.size) / self.radius * self.maxSpeed;\n    if (Math.abs(a) <= 0.01 && Math.abs(b) <= 0.01) return; // pause\n    // calculate offset\n\n    const l = Math.PI / 180;\n    const sc = [Math.sin(a * l), Math.cos(a * l), Math.sin(b * l), Math.cos(b * l)];\n    self.items.forEach(item => {\n      const rx1 = item.x;\n      const ry1 = item.y * sc[1] + item.z * -sc[0];\n      const rz1 = item.y * sc[0] + item.z * sc[1];\n      const rx2 = rx1 * sc[3] + rz1 * sc[2];\n      const ry2 = ry1;\n      const rz2 = rz1 * sc[3] - rx1 * sc[2];\n      const per = 2 * self.depth / (2 * self.depth + rz2); // todo\n\n      item.x = rx2;\n      item.y = ry2;\n      item.z = rz2;\n      item.scale = per.toFixed(3);\n      let alpha = per * per - 0.25;\n      alpha = (alpha > 1 ? 1 : alpha).toFixed(3);\n      const itemEl = item.el;\n      const left = (item.x - itemEl.offsetWidth / 2).toFixed(2);\n      const top = (item.y - itemEl.offsetHeight / 2).toFixed(2);\n      const transform = `translate3d(${left}px, ${top}px, 0) scale(${item.scale})`;\n      itemEl.style.WebkitTransform = transform;\n      itemEl.style.MozTransform = transform;\n      itemEl.style.OTransform = transform;\n      itemEl.style.transform = transform;\n      itemEl.style.filter = `alpha(opacity=${100 * alpha})`;\n      itemEl.style.opacity = alpha;\n    });\n  }\n  /* export instance properties and methods */\n  // update\n\n\n  update(texts) {\n    const self = this; // params\n\n    self.texts = texts || []; // judging and processing items based on texts\n\n    self.texts.forEach((text, index) => {\n      let item = self.items[index];\n\n      if (!item) {\n        // if not had, then create\n        item = self._createTextItem(text, index);\n        Object.assign(item, self._computePosition(index, true)); // random place\n\n        self.$el.appendChild(item.el);\n        self.items.push(item);\n      } // if had, replace text\n\n\n      item.el.innerText = text;\n    }); // remove redundant self.items\n\n    const textsLength = self.texts.length;\n    const itemsLength = self.items.length;\n\n    if (textsLength < itemsLength) {\n      const removeList = self.items.splice(textsLength, itemsLength - textsLength);\n      removeList.forEach(item => {\n        self.$el.removeChild(item.el);\n      });\n    }\n  } // destroy\n\n\n  destroy() {\n    const self = this;\n    self.interval = null; // clear in TagCloud.list\n\n    const index = TagCloud.list.findIndex(e => e.el === self.$el);\n    if (index !== -1) TagCloud.list.splice(index, 1); // clear element\n\n    if (self.$container && self.$el) {\n      self.$container.removeChild(self.$el);\n    }\n  }\n\n  pause() {\n    const self = this;\n    self.paused = true;\n  }\n\n  resume() {\n    const self = this;\n    self.paused = false;\n  }\n\n}\n\nTagCloud.list = [];\nTagCloud._defaultConfig = {\n  radius: 100,\n  // rolling radius, unit `px`\n  maxSpeed: 'normal',\n  // rolling max speed, optional: `slow`, `normal`(default), `fast`\n  initSpeed: 'normal',\n  // rolling init speed, optional: `slow`, `normal`(default), `fast`\n  direction: 135,\n  // rolling init direction, unit clockwise `deg`, optional: `0`(top) , `90`(left), `135`(right-bottom)(default)...\n  keep: true,\n  // whether to keep rolling after mouse out area, optional: `false`, `true`(default)(decelerate to rolling init speed, and keep rolling with mouse)\n  useContainerInlineStyles: true,\n  useItemInlineStyles: true,\n  containerClass: 'tagcloud',\n  itemClass: 'tagcloud--item'\n};\n\nTagCloud._getMaxSpeed = name => ({\n  slow: 0.5,\n  normal: 1,\n  fast: 2\n})[name] || 1;\n\nTagCloud._getInitSpeed = name => ({\n  slow: 16,\n  normal: 32,\n  fast: 80\n})[name] || 32;\n\nexport default ((els, texts, options) => {\n  if (typeof els === 'string') els = document.querySelectorAll(els);\n  if (!els.forEach) els = [els];\n  const instances = [];\n  els.forEach(el => {\n    if (el) {\n      instances.push(new TagCloud(el, texts, options));\n    }\n  });\n  return instances.length <= 1 ? instances[0] : instances;\n});","map":{"version":3,"sources":["/Users/alberto.ramos/Documents/Personal/GitHub/Website3D/src/components/Skills.js"],"names":["React","TagCloud","constructor","container","document","body","texts","options","self","nodeType","Error","$container","config","_defaultConfig","radius","depth","size","maxSpeed","_getMaxSpeed","initSpeed","_getInitSpeed","direction","keep","paused","_createElment","_init","list","push","el","$el","instance","_on","ev","handler","cap","addEventListener","attachEvent","createElement","className","containerClass","useContainerInlineStyles","style","position","width","height","items","forEach","text","index","item","_createTextItem","appendChild","itemEl","itemClass","useItemInlineStyles","willChange","top","left","zIndex","filter","opacity","transformOrigin","WebkitTransformOrigin","MozTransformOrigin","OTransformOrigin","transform","WebkitTransform","MozTransform","OTransform","innerText","_computePosition","random","textsLength","length","Math","floor","phi","acos","theta","sqrt","PI","x","cos","sin","y","z","_requestInterval","fn","delay","requestAnimFrame","window","requestAnimationFrame","callback","element","setTimeout","start","Date","getTime","handle","loop","value","current","delta","call","active","mouseX0","mouseY0","mouseX","mouseY","event","rect","getBoundingClientRect","clientX","clientY","_next","interval","abs","a","min","max","b","l","sc","rx1","ry1","rz1","rx2","ry2","rz2","per","scale","toFixed","alpha","offsetWidth","offsetHeight","update","Object","assign","itemsLength","removeList","splice","removeChild","destroy","findIndex","e","pause","resume","name","slow","normal","fast","els","querySelectorAll","instances"],"mappings":"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","sourcesContent":["import React from 'react'\n\n\nclass TagCloud {\n    /* constructor */\n    constructor(container = document.body, texts, options) {\n        const self = this;\n        if (!container || container.nodeType !== 1) return new Error('Incorrect element type');\n\n        // params\n        self.$container = container;\n        self.texts = texts || [];\n        self.config = { ...TagCloud._defaultConfig, ...options || {} };\n\n        // calculate config\n        self.radius = self.config.radius; // rolling radius\n        self.depth = 2 * self.radius; // rolling depth\n        self.size = 1.5 * self.radius; // rolling area size with mouse\n        self.maxSpeed = TagCloud._getMaxSpeed(self.config.maxSpeed); // rolling max speed\n        self.initSpeed = TagCloud._getInitSpeed(self.config.initSpeed); // rolling init speed\n        self.direction = self.config.direction; // rolling init direction\n        self.keep = self.config.keep; // whether to keep rolling after mouse out area\n        self.paused = false; // keep state to pause the animation\n\n        // create element\n        self._createElment();\n        // init\n        self._init();\n        // set elements and instances\n        TagCloud.list.push({ el: self.$el, container, instance: self });\n    }\n\n    /* static method */\n    // all TagCloud list\n    static list = [];\n\n    // default config\n    static _defaultConfig = {\n        radius: 100, // rolling radius, unit `px`\n        maxSpeed: 'normal', // rolling max speed, optional: `slow`, `normal`(default), `fast`\n        initSpeed: 'normal', // rolling init speed, optional: `slow`, `normal`(default), `fast`\n        direction: 135, // rolling init direction, unit clockwise `deg`, optional: `0`(top) , `90`(left), `135`(right-bottom)(default)...\n        keep: true, // whether to keep rolling after mouse out area, optional: `false`, `true`(default)(decelerate to rolling init speed, and keep rolling with mouse)\n        useContainerInlineStyles: true,\n        useItemInlineStyles: true,\n        containerClass: 'tagcloud',\n        itemClass: 'tagcloud--item'\n    };\n\n    // speed value\n    static _getMaxSpeed = (name) => ({ slow: 0.5, normal: 1, fast: 2 })[name] || 1;\n\n    static _getInitSpeed = (name) => ({ slow: 16, normal: 32, fast: 80 })[name] || 32;\n\n    // event listener\n    static _on(el, ev, handler, cap) {\n        if (el.addEventListener) {\n            el.addEventListener(ev, handler, cap);\n        } else if (el.attachEvent) {\n            el.attachEvent(`on${ev}`, handler);\n        } else {\n            el[`on${ev}`] = handler;\n        }\n    }\n\n    /* instance property method */\n    // create elment\n    _createElment() {\n        const self = this;\n\n        // create container\n        const $el = document.createElement('div');\n        $el.className = self.config.containerClass;\n        if (self.config.useContainerInlineStyles) {\n            $el.style.position = 'relative';\n            $el.style.width = `${2 * self.radius}px`;\n            $el.style.height = `${2 * self.radius}px`;\n        }\n\n        // create texts\n        self.items = [];\n        self.texts.forEach((text, index) => {\n            const item = self._createTextItem(text, index);\n            $el.appendChild(item.el);\n            self.items.push(item);\n        });\n        self.$container.appendChild($el);\n        self.$el = $el;\n    }\n\n    // create a text\n    _createTextItem(text, index = 0) {\n        const self = this;\n        const itemEl = document.createElement('span');\n        itemEl.className = self.config.itemClass;\n        if (self.config.useItemInlineStyles) {\n            itemEl.style.willChange = 'transform, opacity, filter';\n            itemEl.style.position = 'absolute';\n            itemEl.style.top = '50%';\n            itemEl.style.left = '50%';\n            itemEl.style.zIndex = index + 1;\n            itemEl.style.filter = 'alpha(opacity=0)';\n            itemEl.style.opacity = 0;\n            const transformOrigin = '50% 50%';\n            itemEl.style.WebkitTransformOrigin = transformOrigin;\n            itemEl.style.MozTransformOrigin = transformOrigin;\n            itemEl.style.OTransformOrigin = transformOrigin;\n            itemEl.style.transformOrigin = transformOrigin;\n            const transform = 'translate3d(-50%, -50%, 0) scale(1)';\n            itemEl.style.WebkitTransform = transform;\n            itemEl.style.MozTransform = transform;\n            itemEl.style.OTransform = transform;\n            itemEl.style.transform = transform;\n        }\n        itemEl.innerText = text;\n        return {\n            el: itemEl,\n            ...self._computePosition(index), // distributed in appropriate place\n        };\n    }\n\n    // calculate appropriate place\n    _computePosition(index, random = false) {\n        const self = this;\n        const textsLength = self.texts.length;\n        // if random `true`, It means that a random appropriate place is generated, and the position will be independent of `index`\n        if (random) index = Math.floor(Math.random() * (textsLength + 1));\n        const phi = Math.acos(-1 + (2 * index + 1) / textsLength);\n        const theta = Math.sqrt((textsLength + 1) * Math.PI) * phi;\n        return {\n            x: (self.size * Math.cos(theta) * Math.sin(phi)) / 2,\n            y: (self.size * Math.sin(theta) * Math.sin(phi)) / 2,\n            z: (self.size * Math.cos(phi)) / 2,\n        };\n    }\n\n    _requestInterval(fn, delay) {\n        const requestAnimFrame = ((() => window.requestAnimationFrame) || ((callback, element) => {\n            window.setTimeout(callback, 1000 / 60);\n        }))();\n        let start = new Date().getTime();\n        const handle = {};\n        function loop() {\n            handle.value = requestAnimFrame(loop);\n            const current = new Date().getTime(),\n                delta = current - start;\n            if (delta >= delay) {\n                fn.call();\n                start = new Date().getTime();\n            }\n        }\n        handle.value = requestAnimFrame(loop);\n        return handle;\n    }\n\n    // init\n    _init() {\n        const self = this;\n\n        self.active = false; // whether the mouse is activated\n\n        self.mouseX0 = self.initSpeed * Math.sin(self.direction * (Math.PI / 180)); // init distance between the mouse and rolling center x axis\n        self.mouseY0 = -self.initSpeed * Math.cos(self.direction * (Math.PI / 180)); // init distance between the mouse and rolling center y axis\n\n        self.mouseX = self.mouseX0; // current distance between the mouse and rolling center x axis\n        self.mouseY = self.mouseY0; // current distance between the mouse and rolling center y axis\n\n        // mouseover\n        TagCloud._on(self.$el, 'mouseover', () => { self.active = true; });\n        // mouseout\n        TagCloud._on(self.$el, 'mouseout', () => { self.active = false; });\n        // mousemove\n        TagCloud._on(self.keep ? window : self.$el, 'mousemove', (ev) => {\n            ev = ev || window.event;\n            const rect = self.$el.getBoundingClientRect();\n            self.mouseX = (ev.clientX - (rect.left + rect.width / 2)) / 5;\n            self.mouseY = (ev.clientY - (rect.top + rect.height / 2)) / 5;\n        });\n\n        // update state regularly\n        self._next(); // init update state\n        self.interval = self._requestInterval(() => {\n            self._next.call(self);\n        }, 10);\n    }\n\n    // calculate the next state\n    _next() {\n        const self = this;\n\n        if (self.paused) {\n            return;\n        }\n\n        // if keep `false`, pause rolling after moving mouse out area\n        if (!self.keep && !self.active) {\n            self.mouseX = Math.abs(self.mouseX - self.mouseX0) < 1\n                ? self.mouseX0 : (self.mouseX + self.mouseX0) / 2; // reset distance between the mouse and rolling center x axis\n            self.mouseY = Math.abs(self.mouseY - self.mouseY0) < 1\n                ? self.mouseY0 : (self.mouseY + self.mouseY0) / 2; // reset distance between the mouse and rolling center y axis\n        }\n\n        const a = -(Math.min(Math.max(-self.mouseY, -self.size), self.size) / self.radius)\n            * self.maxSpeed;\n        const b = (Math.min(Math.max(-self.mouseX, -self.size), self.size) / self.radius)\n            * self.maxSpeed;\n\n        if (Math.abs(a) <= 0.01 && Math.abs(b) <= 0.01) return; // pause\n\n        // calculate offset\n        const l = Math.PI / 180;\n        const sc = [\n            Math.sin(a * l),\n            Math.cos(a * l),\n            Math.sin(b * l),\n            Math.cos(b * l)\n        ];\n\n        self.items.forEach(item => {\n            const rx1 = item.x;\n            const ry1 = item.y * sc[1] + item.z * (-sc[0]);\n            const rz1 = item.y * sc[0] + item.z * sc[1];\n\n            const rx2 = rx1 * sc[3] + rz1 * sc[2];\n            const ry2 = ry1;\n            const rz2 = rz1 * sc[3] - rx1 * sc[2];\n\n            const per = (2 * self.depth) / (2 * self.depth + rz2); // todo\n\n            item.x = rx2;\n            item.y = ry2;\n            item.z = rz2;\n            item.scale = per.toFixed(3);\n            let alpha = per * per - 0.25;\n            alpha = (alpha > 1 ? 1 : alpha).toFixed(3);\n\n            const itemEl = item.el;\n            const left = (item.x - itemEl.offsetWidth / 2).toFixed(2);\n            const top = (item.y - itemEl.offsetHeight / 2).toFixed(2);\n            const transform = `translate3d(${left}px, ${top}px, 0) scale(${item.scale})`;\n            itemEl.style.WebkitTransform = transform;\n            itemEl.style.MozTransform = transform;\n            itemEl.style.OTransform = transform;\n            itemEl.style.transform = transform;\n            itemEl.style.filter = `alpha(opacity=${100 * alpha})`;\n            itemEl.style.opacity = alpha;\n        });\n    }\n\n    /* export instance properties and methods */\n    // update\n    update(texts) {\n        const self = this;\n        // params\n        self.texts = texts || [];\n        // judging and processing items based on texts\n        self.texts.forEach((text, index) => {\n            let item = self.items[index];\n            if (!item) { // if not had, then create\n                item = self._createTextItem(text, index);\n                Object.assign(item, self._computePosition(index, true)); // random place\n                self.$el.appendChild(item.el);\n                self.items.push(item);\n            }\n            // if had, replace text\n            item.el.innerText = text;\n        });\n        // remove redundant self.items\n        const textsLength = self.texts.length;\n        const itemsLength = self.items.length;\n        if (textsLength < itemsLength) {\n            const removeList = self.items.splice(textsLength, itemsLength - textsLength);\n            removeList.forEach(item => {\n                self.$el.removeChild(item.el);\n            });\n        }\n    }\n\n    // destroy\n    destroy() {\n        const self = this;\n        self.interval = null;\n        // clear in TagCloud.list\n        const index = TagCloud.list.findIndex(e => e.el === self.$el);\n        if (index !== -1) TagCloud.list.splice(index, 1);\n        // clear element\n        if (self.$container && self.$el) {\n            self.$container.removeChild(self.$el);\n        }\n    }\n\n    pause() {\n        const self = this;\n\n        self.paused = true;\n    }\n\n    resume() {\n        const self = this;\n\n        self.paused = false;\n    }\n}\n\nexport default (els, texts, options) => {\n    if (typeof els === 'string') els = document.querySelectorAll(els);\n    if (!els.forEach) els = [els];\n    const instances = [];\n    els.forEach(el => {\n        if (el) {\n            instances.push(new TagCloud(el, texts, options));\n        }\n    });\n    return instances.length <= 1 ? instances[0] : instances;\n};"]},"metadata":{},"sourceType":"module"}